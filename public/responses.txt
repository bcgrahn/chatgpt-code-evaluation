

# Noughts and Crosses game in Python

# We will use a 3x3 board
board = [["_","_","_"],["_","_","_"],["_","_","_"]]

# Print the board
def print_board():
  for row in board:
    print(row)

# Check for a winner
def check_win(player):
  # Check for horizontal win
  for row in board:
    if row == [player,player,player]:
      return True
  # Check for vertical win
  for col in range(3):
    if board[0][col] == player and board[1][col] == player and board[2][col] == player:
      return True
  # Check for diagonal win
  if board[0][0] == player and board[1][1] == player and board[2][2] == player:
    return True
  if board[0][2] == player and board[1][1] == player and board[2][0] == player:
    return True
  return False

# Main game loop
player = "X"
while True:
  print_board()
  # Get input from the player
  valid_input = False
  while not valid_input:
    row = int(input("Enter a row (0, 1, 2): "))
    col = int(input("Enter a column (0, 1, 2): "))
    if row >= 0 and row < 3 and col >= 0 and col < 3 and board[row][col] == "_":
      board[row][col] = player
      valid_input = True
    else:
      print("Invalid input. Try again.")
  # Check for a winner
  if check_win(player):
    print_board()
    print(player + " wins!")
    break
  # Switch players
  if player == "X":
    player = "O"
  else:
    player = "X"


def bubble_sort(arr):
    n = len(arr)
 
    # Traverse through all array elements
    for i in range(n):
 
        # Last i elements are already in place
        for j in range(0, n-i-1):
 
            # traverse the array from 0 to n-i-1
            # Swap if the element found is greater
            # than the next element
            if arr[j] > arr[j+1] :
                arr[j], arr[j+1] = arr[j+1], arr[j]
 
# Driver code to test above
arr = [64, 34, 25, 12, 22, 11, 90]
 
bubble_sort(arr)
 
print ("Sorted array is:")
for i in range(len(arr)):
    print ("%d" %arr[i]),


# Python program to demonstrate insert operation in binary search tree  
  
# A utility class that represents an individual node in a BST 
class Node: 
    def __init__(self,key): 
        self.left = None
        self.right = None
        self.val = key 
  
# A utility function to insert a new node with the given key 
def insert(root,node): 
    if root is None: 
        root = node 
    else: 
        if root.val < node.val: 
            if root.right is None: 
                root.right = node 
            else: 
                insert(root.right, node) 
        else: 
            if root.left is None: 
                root.left = node 
            else: 
                insert(root.left, node) 
  
# A utility function to do inorder tree traversal 
def inorder(root): 
    if root: 
        inorder(root.left) 
        print(root.val) 
        inorder(root.right) 
  
  
# Driver program to test the above functions 
# Let us create the following BST 
#      50 
#    /      \ 
#   30     70 
#   / \    / \ 
#  20 40  60 80 
r = Node(50) 
insert(r,Node(30)) 
insert(r,Node(20)) 
insert(r,Node(40)) 
insert(r,Node(70)) 
insert(r,Node(60)) 
insert(r,Node(80)) 
  
# Print inoder traversal of the BST 
inorder(r)
I am a software engineer and I am currently working on a project that requires me to use a variety of different technologies. I have experience with HTML, CSS, JavaScript, PHP, MySQL, and other web technologies. I am also familiar with Linux, Windows, and Mac OS X operating systems. I have a strong understanding of software development processes, including design, coding, testing, and deployment. I have experience in both front-end and back-end development, as well as working with APIs and web services. I am comfortable working in both Agile and Waterfall development environments. I am also familiar with version control systems such as Git, SVN, and Mercurial. Additionally, I have experience with mobile development, including Android and iOS.
