

# This is a noughts and crosses game for two players

# Create the board
board = [1, 2, 3,
         4, 5, 6,
         7, 8, 9]

# Print the board
def print_board():
    print(board[0], '|', board[1], '|', board[2])
    print('----------')
    print(board[3], '|', board[4], '|', board[5])
    print('----------')
    print(board[6], '|', board[7], '|', board[8])

# Function to check if someone has won
def check_win():
    # Check horizontal
    if board[0] == board[1] == board[2]:
        return board[0]
    elif board[3] == board[4] == board[5]:
        return board[3]
    elif board[6] == board[7] == board[8]:
        return board[6]
    # Check vertical
    elif board[0] == board[3] == board[6]:
        return board[0]
    elif board[1] == board[4] == board[7]:
        return board[1]
    elif board[2] == board[5] == board[8]:
        return board[2]
    # Check diagonal
    elif board[0] == board[4] == board[8]:
        return board[0]
    elif board[2] == board[4] == board[6]:
        return board[2]
    else:
        return None

# Function to check if the board is full
def check_full():
    for i in board:
        if i != 'X' and i != 'O':
            return False
    return True

# Main game loop
player = 'X'
while True:
    print_board()
    # Get player input
    position = int(input('Player ' + player + ', choose a position (1-9): '))
    # Check if position is valid
    if position > 0 and position < 10:
        if board[position-1] != 'X' and board[position-1] != 'O':
            board[position-1] = player
            # Check for win
            if check_win() == 'X' or check_win() == 'O':
                print_board()
                print('Player', player, 'wins!')
                break
            # Check for draw
            if check_full():
                print_board()
                print('Draw!')
                break
            # Switch player
            if player == 'X':
                player = 'O'
            else:
                player = 'X'
        else:
            print('Position taken!')
    else:
        print('Please choose a valid position (1-9)')


def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    else:
        pivot = arr[0]
        left = [x for x in arr[1:] if x < pivot]
        right = [x for x in arr[1:] if x >= pivot]
        return quick_sort(left) + [pivot] + quick_sort(right)


class Node: 
    def __init__(self, data): 
        self.data = data  
        self.left = None
        self.right = None
  
# A function to do inorder tree traversal 
def inorder(root): 
  
    if root is not None: 
        inorder(root.left) 
        print(root.data) 
        inorder(root.right) 
  
# A function to insert a new node in the binary search tree 
def insert( node, data): 
  
    # If the tree is empty, return a new node 
    if node is None: 
        return Node(data) 
  
    else: 
        # Otherwise, recur down the tree 
        if data <= node.data: 
            node.left = insert(node.left, data) 
        else: 
            node.right = insert(node.right, data) 
  
        # return the (unchanged) node pointer 
        return node 
  
# Driver program to test the above functions 
# Let us create the following BST 
#      50 
#    /      \ 
#   30     70 
#   / \    / \ 
#  20 40  60 80 
root = None
root = insert(root, 50) 
insert(root, 30) 
insert(root, 20) 
insert(root, 40) 
insert(root, 70) 
insert(root, 60) 
insert(root, 80) 
  
# Print inoder traversal of the BST 
inorder(root)
